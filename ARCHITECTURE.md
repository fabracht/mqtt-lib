# MQTT v5.0 Platform Architecture

This document describes the architecture of both the MQTT client library and broker implementation.

## Core Architectural Principle: Direct Async/Await

This library uses Rust's native async/await patterns throughout. Rust's async ecosystem is based on:

- State machines generated by the compiler
- Futures that represent asynchronous computations
- The async runtime (Tokio) that polls these futures

We use direct async/await patterns because:

1. Tokio already provides the async runtime
2. Direct async calls are more efficient and idiomatic in Rust
3. The code is simpler and easier to debug

## Architecture Overview

### Core Components

1. **MqttClient**: The main client struct

   - Holds shared state (transport, session, callbacks)
   - Provides direct async methods for all operations
   - Uses direct async/await patterns

2. **Transport Layer**: Direct async I/O

   - `read_packet()` - async method that waits for next packet
   - `write_packet()` - async method that sends a packet
   - Implemented for TCP, TLS, WebSocket, UDP (with reliability layer), DTLS

3. **Session State**: Shared state management

   - Wrapped in Arc<RwLock<T>> for concurrent access
   - Accessed directly by client methods
   - Direct state access pattern

4. **TLS/DTLS Configuration**: Secure transport setup

   - Stored TLS config (Arc<RwLock<Option<TlsConfig>>>) for client certificates and CA certs
   - Stored DTLS config (Arc<RwLock<Option<DtlsConfig>>>) for secure UDP
   - `set_tls_config()` method for CA-only verification or mutual TLS (mTLS)
   - `set_dtls_config()` method for PSK or certificate-based DTLS
   - Config applied automatically when connecting to mqtts:// or mqtts-dtls:// URLs

5. **Background Tasks**: Specific focused tasks
   - Packet reader: Continuously reads packets
   - Keep-alive: Sends pings at intervals
   - Reconnection: Handles connection recovery
   - Each is a simple async function

### Data Flow

1. **Incoming Packets**:

   ```
   Network -> Transport.read_packet() -> packet_reader_task -> handle_packet() -> callbacks
   ```

2. **Outgoing Operations**:

   ```
   Client method -> Transport.write_packet() -> Network
   ```

3. **No Indirection**: Operations go directly from API call to network I/O

## Broker Architecture

The MQTT broker follows the same architectural principles as the client - direct async/await patterns.

### Broker Core Components

1. **MqttBroker**: The main broker struct

   - Manages configuration and lifecycle
   - Spawns listening tasks for each transport

2. **Server Listeners**: One per transport type

   - TCP listener: Direct `accept()` loop
   - TLS listener: TLS wrapper around TCP with rustls
   - WebSocket listener: HTTP upgrade handling with tokio-tungstenite
   - UDP handler: Packet-based with session management
   - DTLS handler: Secure UDP with webrtc-dtls
   - Each spawns client handlers directly

3. **ClientHandler**: Per-client connection handler

   - Direct async packet reading and writing
   - Manages client session state
   - Handles MQTT protocol directly

4. **Message Router**: Subscription matching and delivery

   - Message routing to subscribers
   - Shared subscription support
   - Thread-safe concurrent access

5. **Storage Backend**: Persistence layer
   - Sessions, retained messages, queued messages
   - File-based or in-memory implementations
   - async I/O operations

### Broker Data Flow

1. **Connection Acceptance**:

   ```
   TCP/TLS/WS Listener -> accept() -> spawn(ClientHandler::new())
   ```

2. **Packet Processing**:

   ```
   Client -> Transport.read_packet() -> ClientHandler.handle_packet() -> Router/Storage
   ```

3. **Message Routing**:
   ```
   Publisher -> Router.route_message() -> matching subscribers -> Transport.write_packet()
   ```

### Broker-Specific Components

1. **Authentication Manager**:

   - Direct auth checks during CONNECT
   - Pluggable auth providers via AuthProvider trait:
     - `AllowAllAuthProvider` - No authentication (development only)
     - `PasswordAuthProvider` - File-based username/password with bcrypt
     - `CertificateAuthProvider` - Client certificate validation
     - `ComprehensiveAuthProvider` - Combines multiple auth methods
   - Password file format compatible with mosquitto
   - Bcrypt password hashing for secure storage
   - CLI `passwd` command for password management

2. **ACL Manager**:

   - Direct authorization checks for publish/subscribe
   - Rule-based access control
   - Integrated with packet handlers

3. **Resource Monitor**:

   - Tracks connections, bandwidth, messages
   - Enforces rate limits and quotas
   - Direct checks, no monitoring loops

4. **Bridge Manager**:

   - Manages broker-to-broker connections
   - Each bridge is a client to remote broker
   - Direct message forwarding based on rules

5. **$SYS Topics Provider**:

   - Publishes broker statistics
   - Simple periodic task
   - Direct publish to router

6. **Session Takeover**:
   - Handles new client connections with existing client IDs
   - Uses oneshot channels for disconnect signaling
   - Router tracks disconnect channels per client ID
   - Graceful disconnection of previous client when takeover occurs
   - Maintains MQTT v5.0 session takeover semantics

## Platform Integration

Both client and broker share:

1. **Common Protocol Implementation**:

   - Shared packet encoding/decoding
   - Same MQTT v5.0 compliance
   - Reusable validation logic

2. **Transport Abstraction**:

   - Same TCP/TLS/WebSocket/UDP/DTLS code
   - Unified connection handling via TransportType enum
   - Shared TLS configuration with rustls
   - UDP reliability layer with automatic retransmission
   - UDP fragmentation for packets exceeding MTU
   - DTLS support via webrtc-dtls with PSK and certificate auth

3. **Architectural Principles**:
   - Direct async/await throughout
   - Shared error handling patterns

## UDP/DTLS Transport Architecture

The UDP/DTLS transport implementation provides reliable MQTT messaging over UDP with optional encryption:

### UDP Transport Components

1. **Reliability Layer** (`transport/udp_reliability.rs`):

   - Implements reliable delivery over unreliable UDP
   - Automatic retransmission with configurable timeouts
   - Sequence numbering and acknowledgment tracking
   - Out-of-order packet handling

2. **Fragmentation Layer** (`transport/udp_fragmentation.rs`):

   - Handles packets exceeding UDP MTU (typically 1472 bytes)
   - Automatic fragmentation and reassembly
   - Fragment sequencing and reassembly tracking
   - Configurable MTU size

3. **Session Management** (`broker/udp_session.rs`):

   - Maps UDP socket addresses to MQTT client sessions
   - Maintains state for each UDP client
   - Handles session expiry and cleanup
   - Per-client packet buffering

4. **DTLS Handler** (`broker/dtls_handler.rs`, `transport/dtls.rs`):
   - Secure UDP using DTLS (via webrtc-dtls)
   - Pre-Shared Key (PSK) authentication
   - Certificate-based authentication
   - Seamless integration with UDP reliability layer

### URL Schemes

- `mqtt-udp://host:port` - Unencrypted UDP with reliability
- `mqtts-dtls://host:port` - Encrypted UDP with DTLS

### Use Cases

- IoT devices with intermittent connectivity
- Scenarios where connection setup overhead should be minimized

## Testing Architecture

1. **Unit Tests**:

   - Direct testing of components
   - Simple async patterns

2. **Integration Tests**:

   - Full client-broker communication
   - Network simulation with Turmoil
   - Property-based testing
