# MQTT v5.0 Platform Architecture

This document describes the architecture of both the MQTT client library and broker implementation.

## Core Architectural Principle: Direct Async/Await

This library uses Rust's native async/await patterns throughout. Rust's async ecosystem is based on:

- State machines generated by the compiler
- Futures that represent asynchronous computations
- The async runtime (Tokio) that polls these futures

We use direct async/await patterns because:

1. Tokio already provides the async runtime
2. Direct async calls are more efficient and idiomatic in Rust
3. The code is simpler and easier to debug

## Architecture Overview

### Core Components

1. **MqttClient**: The main client struct

   - Holds shared state (transport, session, callbacks)
   - Provides direct async methods for all operations
   - Uses direct async/await patterns

2. **Transport Layer**: Direct async I/O

   - `read_packet()` - async method that waits for next packet
   - `write_packet()` - async method that sends a packet
   - Implemented for TCP, TLS, WebSocket

3. **Session State**: Shared state management

   - Wrapped in Arc<RwLock<T>> for concurrent access
   - Accessed directly by client methods
   - Direct state access pattern

4. **TLS Configuration**: Secure transport setup

   - Stored TLS config (Arc<RwLock<Option<TlsConfig>>>) for client certificates and CA certs
   - `set_tls_config()` method for CA-only verification or mutual TLS (mTLS)
   - Config applied automatically when connecting to mqtts:// URLs

5. **Background Tasks**: Specific focused tasks
   - Packet reader: Continuously reads packets
   - Keep-alive: Sends pings at intervals
   - Reconnection: Handles connection recovery with exponential backoff
   - Each is a simple async function

6. **Automatic Reconnection**: Opt-in connection recovery
   - Disabled by default (`ReconnectConfig::enabled = false`)
   - Exponential backoff with configurable delays
   - Automatic subscription restoration based on `session_present` flag
   - Library handles reconnection transparently when enabled

### Data Flow

1. **Incoming Packets**:

   ```
   Network -> Transport.read_packet() -> packet_reader_task -> handle_packet() -> callbacks
   ```

2. **Outgoing Operations**:

   ```
   Client method -> Transport.write_packet() -> Network
   ```

3. **No Indirection**: Operations go directly from API call to network I/O

### Client Error Handling

The client validates all acknowledgment reason codes from the broker to ensure MQTT v5.0 compliance:

1. **PUBACK Validation** (QoS 1): Client checks PUBACK reason code after publishing
   - Success codes (0x00-0x7F): Operation completes successfully
   - Error codes (0x80+): Returns `MqttError::PublishFailed(reason_code)`

2. **PUBREC Validation** (QoS 2): Client checks PUBREC reason code
   - Error codes abort the publish flow immediately
   - Success codes proceed to PUBREL/PUBCOMP handshake

3. **PUBCOMP Validation** (QoS 2): Client checks final acknowledgment
   - Ensures complete QoS 2 flow validation
   - Reports final broker decision on publish

4. **Authorization Integration**:
   - Properly handles `ReasonCode::NotAuthorized` (0x87) from ACL failures
   - Returns descriptive errors when broker rejects due to permissions, quotas, or other constraints
   - Prevents false success reporting when broker rejects publish

This ensures the client API accurately reflects broker acceptance or rejection of messages, fixing the previous behavior where the client reported success even when the broker rejected the publish.

## Broker Architecture

The MQTT broker follows the same architectural principles as the client - direct async/await patterns.

### Broker Core Components

1. **MqttBroker**: The main broker struct

   - Manages configuration and lifecycle
   - Spawns listening tasks for each transport

2. **Server Listeners**: One per transport type

   - TCP listener: Direct `accept()` loop
   - TLS listener: TLS wrapper around TCP with rustls
   - WebSocket listener: HTTP upgrade handling with tokio-tungstenite
   - Each spawns client handlers directly

3. **ClientHandler**: Per-client connection handler

   - Direct async packet reading and writing
   - Manages client session state
   - Handles MQTT protocol directly

4. **Message Router**: Subscription matching and delivery

   - MQTT spec-compliant topic matching with wildcard support
   - System topic protection (`$` topics excluded from root wildcards)
   - Shared subscription support
   - Thread-safe concurrent access

5. **Storage Backend**: Persistence layer
   - Sessions, retained messages, queued messages
   - File-based or in-memory implementations
   - async I/O operations

### Broker Data Flow

1. **Connection Acceptance**:

   ```
   TCP/TLS/WS Listener -> accept() -> spawn(ClientHandler::new())
   ```

2. **Packet Processing**:

   ```
   Client -> Transport.read_packet() -> ClientHandler.handle_packet() -> Router/Storage
   ```

3. **Message Routing**:
   ```
   Publisher -> Router.route_message() -> matching subscribers -> Transport.write_packet()
   ```

### Broker-Specific Components

1. **Authentication Manager**:

   - Direct auth checks during CONNECT
   - Pluggable auth providers via AuthProvider trait:
     - `AllowAllAuthProvider` - No authentication (development only)
     - `PasswordAuthProvider` - File-based username/password with bcrypt
     - `CertificateAuthProvider` - Client certificate validation
     - `ComprehensiveAuthProvider` - Combines multiple auth methods
   - Custom provider composition via `with_providers()` constructor
   - Bcrypt password hashing for secure storage
   - CLI `passwd` command for password management
   - Debug logging for authorization decisions (troubleshooting support)

2. **ACL Manager**:

   - Direct authorization checks for publish/subscribe
   - Rule-based access control with wildcard matching
   - Integrated with packet handlers
   - Debug logging for authorization decisions
   - Warn logging for authorization failures
   - CLI management via `mqttv5 acl` command (add, remove, list, check)

3. **Resource Monitor**:

   - Tracks connections, bandwidth, messages
   - Enforces rate limits and quotas
   - Direct checks, no monitoring loops

4. **Bridge Manager**:

   - Manages broker-to-broker connections
   - Each bridge is a client to remote broker
   - Direct message forwarding based on topic mappings
   - Full TLS/mTLS support with CA and client certificates
   - AWS IoT integration via ALPN protocols
   - Exponential backoff reconnection (5s → 10s → 20s → 300s max)
   - Backup broker failover support

5. **$SYS Topics Provider**:

   - Publishes broker statistics to `$SYS/#` topics
   - Simple periodic task
   - Direct publish to router
   - Requires explicit `$SYS/#` subscription (not matched by `#`)

6. **Session Takeover**:
   - Handles new client connections with existing client IDs
   - Uses oneshot channels for disconnect signaling
   - Router tracks disconnect channels per client ID
   - Graceful disconnection of previous client when takeover occurs
   - Maintains MQTT v5.0 session takeover semantics

## Platform Integration

Both client and broker share:

1. **Common Protocol Implementation**:

   - Shared packet encoding/decoding
   - Same MQTT v5.0 compliance
   - Reusable validation logic

2. **Transport Abstraction**:

   - Same TCP/TLS/WebSocket code
   - Unified connection handling via TransportType enum
   - Shared TLS configuration with rustls

3. **Architectural Principles**:
   - Direct async/await throughout
   - Shared error handling patterns

4. **Topic Matching**:
   - MQTT v5.0 spec-compliant wildcard matching
   - `+` matches one level, `#` matches remaining levels
   - Topics starting with `$` excluded from root wildcards (`#`, `+`)
   - Requires explicit `$SYS/#` subscription for system topics

## Testing Architecture

1. **Unit Tests**: Direct testing of components with simple async patterns

2. **Integration Tests**: Full client-broker communication with Turmoil network simulation

3. **BDD Tests**: Cucumber tests in `tests/bdd/` validate CLI workflows and reconnection scenarios
