# MQTT v5.0 Platform Architecture

This document describes the architecture of both the MQTT client library and broker implementation.

## Core Architectural Principle: Direct Async/Await

This library uses Rust's native async/await patterns throughout. Rust's async ecosystem is based on:

- State machines generated by the compiler
- Futures that represent asynchronous computations
- The async runtime (Tokio) that polls these futures

We use direct async/await patterns because:

1. Tokio already provides the async runtime
2. Direct async calls are more efficient and idiomatic in Rust
3. The code is simpler and easier to debug

## Architecture Overview

### Core Components

1. **MqttClient**: The main client struct

   - Holds shared state (transport, session, callbacks)
   - Provides direct async methods for all operations
   - Uses direct async/await patterns

2. **Transport Layer**: Direct async I/O

   - `read_packet()` - async method that waits for next packet
   - `write_packet()` - async method that sends a packet
   - Implemented for TCP, TLS, WebSocket

3. **Session State**: Shared state management

   - Wrapped in Arc<RwLock<T>> for concurrent access
   - Accessed directly by client methods
   - Direct state access pattern

4. **TLS Configuration**: Secure transport setup

   - Stored TLS config (Arc<RwLock<Option<TlsConfig>>>) for client certificates and CA certs
   - `set_tls_config()` method for CA-only verification or mutual TLS (mTLS)
   - Config applied automatically when connecting to mqtts:// URLs

5. **Background Tasks**: Specific focused tasks
   - Packet reader: Continuously reads packets
   - Keep-alive: Sends pings at intervals
   - Reconnection: Handles connection recovery with exponential backoff
   - Each is a simple async function

6. **Automatic Reconnection**: Opt-in connection recovery
   - Disabled by default (`ReconnectConfig::enabled = false`)
   - Exponential backoff with configurable delays
   - Automatic subscription restoration based on `session_present` flag
   - Library handles reconnection transparently when enabled

### Data Flow

1. **Incoming Packets**:

   ```
   Network -> Transport.read_packet() -> packet_reader_task -> handle_packet() -> callbacks
   ```

2. **Outgoing Operations**:

   ```
   Client method -> Transport.write_packet() -> Network
   ```

3. **No Indirection**: Operations go directly from API call to network I/O

## Broker Architecture

The MQTT broker follows the same architectural principles as the client - direct async/await patterns.

### Broker Core Components

1. **MqttBroker**: The main broker struct

   - Manages configuration and lifecycle
   - Spawns listening tasks for each transport

2. **Server Listeners**: One per transport type

   - TCP listener: Direct `accept()` loop
   - TLS listener: TLS wrapper around TCP with rustls
   - WebSocket listener: HTTP upgrade handling with tokio-tungstenite
   - Each spawns client handlers directly

3. **ClientHandler**: Per-client connection handler

   - Direct async packet reading and writing
   - Manages client session state
   - Handles MQTT protocol directly

4. **Message Router**: Subscription matching and delivery

   - Message routing to subscribers
   - Shared subscription support
   - Thread-safe concurrent access

5. **Storage Backend**: Persistence layer
   - Sessions, retained messages, queued messages
   - File-based or in-memory implementations
   - async I/O operations

### Broker Data Flow

1. **Connection Acceptance**:

   ```
   TCP/TLS/WS Listener -> accept() -> spawn(ClientHandler::new())
   ```

2. **Packet Processing**:

   ```
   Client -> Transport.read_packet() -> ClientHandler.handle_packet() -> Router/Storage
   ```

3. **Message Routing**:
   ```
   Publisher -> Router.route_message() -> matching subscribers -> Transport.write_packet()
   ```

### Broker-Specific Components

1. **Authentication Manager**:

   - Direct auth checks during CONNECT
   - Pluggable auth providers via AuthProvider trait:
     - `AllowAllAuthProvider` - No authentication (development only)
     - `PasswordAuthProvider` - File-based username/password with bcrypt
     - `CertificateAuthProvider` - Client certificate validation
     - `ComprehensiveAuthProvider` - Combines multiple auth methods
   - Bcrypt password hashing for secure storage
   - CLI `passwd` command for password management

2. **ACL Manager**:

   - Direct authorization checks for publish/subscribe
   - Rule-based access control
   - Integrated with packet handlers

3. **Resource Monitor**:

   - Tracks connections, bandwidth, messages
   - Enforces rate limits and quotas
   - Direct checks, no monitoring loops

4. **Bridge Manager**:

   - Manages broker-to-broker connections
   - Each bridge is a client to remote broker
   - Direct message forwarding based on rules

5. **$SYS Topics Provider**:

   - Publishes broker statistics
   - Simple periodic task
   - Direct publish to router

6. **Session Takeover**:
   - Handles new client connections with existing client IDs
   - Uses oneshot channels for disconnect signaling
   - Router tracks disconnect channels per client ID
   - Graceful disconnection of previous client when takeover occurs
   - Maintains MQTT v5.0 session takeover semantics

## Platform Integration

Both client and broker share:

1. **Common Protocol Implementation**:

   - Shared packet encoding/decoding
   - Same MQTT v5.0 compliance
   - Reusable validation logic

2. **Transport Abstraction**:

   - Same TCP/TLS/WebSocket code
   - Unified connection handling via TransportType enum
   - Shared TLS configuration with rustls

3. **Architectural Principles**:
   - Direct async/await throughout
   - Shared error handling patterns

## Testing Architecture

1. **Unit Tests**: Direct testing of components with simple async patterns

2. **Integration Tests**: Full client-broker communication with Turmoil network simulation

3. **BDD Tests**: Cucumber tests in `tests/bdd/` validate CLI workflows and reconnection scenarios
