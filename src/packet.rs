pub mod auth;
pub mod connack;
pub mod connect;
pub mod disconnect;
pub mod pingreq;
pub mod pingresp;
pub mod puback;
pub mod pubcomp;
pub mod publish;
pub mod pubrec;
pub mod pubrel;
pub mod suback;
pub mod subscribe;
pub mod unsuback;
pub mod unsubscribe;

use crate::encoding::{decode_variable_int, encode_variable_int};
use crate::error::{MqttError, Result};
use bebytes::BeBytes;
use bytes::{Buf, BufMut};

#[derive(Debug, Clone, Copy, PartialEq, Eq, BeBytes)]
pub enum PacketType {
    Connect = 1,
    ConnAck = 2,
    Publish = 3,
    PubAck = 4,
    PubRec = 5,
    PubRel = 6,
    PubComp = 7,
    Subscribe = 8,
    SubAck = 9,
    Unsubscribe = 10,
    UnsubAck = 11,
    PingReq = 12,
    PingResp = 13,
    Disconnect = 14,
    Auth = 15,
}

impl PacketType {
    /// Converts a u8 to `PacketType`
    #[must_use]
    pub fn from_u8(value: u8) -> Option<Self> {
        // Use the TryFrom implementation generated by BeBytes
        Self::try_from(value).ok()
    }
}

impl From<PacketType> for u8 {
    fn from(packet_type: PacketType) -> Self {
        packet_type as u8
    }
}

/// MQTT packet fixed header
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct FixedHeader {
    pub packet_type: PacketType,
    pub flags: u8,
    pub remaining_length: u32,
}

impl FixedHeader {
    /// Creates a new fixed header
    #[must_use]
    pub fn new(packet_type: PacketType, flags: u8, remaining_length: u32) -> Self {
        Self {
            packet_type,
            flags,
            remaining_length,
        }
    }

    /// Encodes the fixed header
    ///
    /// # Errors
    ///
    /// Returns an error if the remaining length is too large
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails
    pub fn encode<B: BufMut>(&self, buf: &mut B) -> Result<()> {
        let byte1 = (u8::from(self.packet_type) << 4) | (self.flags & 0x0F);
        buf.put_u8(byte1);
        encode_variable_int(buf, self.remaining_length)?;
        Ok(())
    }

    /// Decodes a fixed header from the buffer
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - Insufficient bytes in buffer
    /// - Invalid packet type
    /// - Invalid remaining length
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails
    pub fn decode<B: Buf>(buf: &mut B) -> Result<Self> {
        if !buf.has_remaining() {
            return Err(MqttError::MalformedPacket(
                "No data for fixed header".to_string(),
            ));
        }

        let byte1 = buf.get_u8();
        let packet_type_val = (byte1 >> 4) & 0x0F;
        let flags = byte1 & 0x0F;

        let packet_type = PacketType::from_u8(packet_type_val)
            .ok_or(MqttError::InvalidPacketType(packet_type_val))?;

        let remaining_length = decode_variable_int(buf)?;

        Ok(Self {
            packet_type,
            flags,
            remaining_length,
        })
    }

    /// Validates the flags for the packet type
    #[must_use]
    pub fn validate_flags(&self) -> bool {
        match self.packet_type {
            PacketType::Publish => true, // Publish has variable flags
            PacketType::PubRel | PacketType::Subscribe | PacketType::Unsubscribe => {
                self.flags == 0x02
            }
            _ => self.flags == 0,
        }
    }

    /// Returns the encoded length of the fixed header
    #[must_use]
    pub fn encoded_len(&self) -> usize {
        // 1 byte for packet type + flags, plus variable length encoding of remaining length
        1 + crate::encoding::encoded_variable_int_len(self.remaining_length)
    }
}

/// Enum representing all MQTT packet types
#[derive(Debug, Clone)]
pub enum Packet {
    Connect(Box<connect::ConnectPacket>),
    ConnAck(connack::ConnAckPacket),
    Publish(publish::PublishPacket),
    PubAck(puback::PubAckPacket),
    PubRec(pubrec::PubRecPacket),
    PubRel(pubrel::PubRelPacket),
    PubComp(pubcomp::PubCompPacket),
    Subscribe(subscribe::SubscribePacket),
    SubAck(suback::SubAckPacket),
    Unsubscribe(unsubscribe::UnsubscribePacket),
    UnsubAck(unsuback::UnsubAckPacket),
    PingReq,
    PingResp,
    Disconnect(disconnect::DisconnectPacket),
    Auth(auth::AuthPacket),
}

/// Trait for MQTT packets
pub trait MqttPacket: Sized {
    /// Returns the packet type
    fn packet_type(&self) -> PacketType;

    /// Returns the fixed header flags
    fn flags(&self) -> u8 {
        0
    }

    /// Encodes the packet body (without fixed header)
    ///
    /// # Errors
    ///
    /// Returns an error if encoding fails
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails
    fn encode_body<B: BufMut>(&self, buf: &mut B) -> Result<()>;

    /// Decodes the packet body (without fixed header)
    ///
    /// # Errors
    ///
    /// Returns an error if decoding fails
    fn decode_body<B: Buf>(buf: &mut B, fixed_header: &FixedHeader) -> Result<Self>;

    /// Encodes the complete packet (with fixed header)
    ///
    /// # Errors
    ///
    /// Returns an error if encoding fails
    fn encode<B: BufMut>(&self, buf: &mut B) -> Result<()> {
        // First encode to temporary buffer to get remaining length
        let mut body = Vec::new();
        self.encode_body(&mut body)?;

        let fixed_header = FixedHeader::new(
            self.packet_type(),
            self.flags(),
            body.len().try_into().unwrap_or(u32::MAX),
        );

        fixed_header.encode(buf)?;
        buf.put_slice(&body);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use bytes::BytesMut;

    #[test]
    fn test_packet_type_from_u8() {
        assert_eq!(PacketType::from_u8(1), Some(PacketType::Connect));
        assert_eq!(PacketType::from_u8(2), Some(PacketType::ConnAck));
        assert_eq!(PacketType::from_u8(15), Some(PacketType::Auth));
        assert_eq!(PacketType::from_u8(0), None);
        assert_eq!(PacketType::from_u8(16), None);
    }

    #[test]
    fn test_fixed_header_encode_decode() {
        let mut buf = BytesMut::new();

        let header = FixedHeader::new(PacketType::Connect, 0, 100);
        header.encode(&mut buf).unwrap();

        let decoded = FixedHeader::decode(&mut buf).unwrap();
        assert_eq!(decoded.packet_type, PacketType::Connect);
        assert_eq!(decoded.flags, 0);
        assert_eq!(decoded.remaining_length, 100);
    }

    #[test]
    fn test_fixed_header_with_flags() {
        let mut buf = BytesMut::new();

        let header = FixedHeader::new(PacketType::Publish, 0x0D, 50);
        header.encode(&mut buf).unwrap();

        let decoded = FixedHeader::decode(&mut buf).unwrap();
        assert_eq!(decoded.packet_type, PacketType::Publish);
        assert_eq!(decoded.flags, 0x0D);
        assert_eq!(decoded.remaining_length, 50);
    }

    #[test]
    fn test_validate_flags() {
        let header = FixedHeader::new(PacketType::Connect, 0, 0);
        assert!(header.validate_flags());

        let header = FixedHeader::new(PacketType::Connect, 1, 0);
        assert!(!header.validate_flags());

        let header = FixedHeader::new(PacketType::Subscribe, 0x02, 0);
        assert!(header.validate_flags());

        let header = FixedHeader::new(PacketType::Subscribe, 0x00, 0);
        assert!(!header.validate_flags());

        let header = FixedHeader::new(PacketType::Publish, 0x0F, 0);
        assert!(header.validate_flags());
    }

    #[test]
    fn test_decode_insufficient_data() {
        let mut buf = BytesMut::new();
        let result = FixedHeader::decode(&mut buf);
        assert!(result.is_err());
    }

    #[test]
    fn test_decode_invalid_packet_type() {
        let mut buf = BytesMut::new();
        buf.put_u8(0x00); // Invalid packet type 0
        buf.put_u8(0x00); // Remaining length

        let result = FixedHeader::decode(&mut buf);
        assert!(result.is_err());
    }

    #[test]
    fn test_packet_type_bebytes_serialization() {
        // Test BeBytes to_be_bytes and try_from_be_bytes
        let packet_type = PacketType::Publish;
        let bytes = packet_type.to_be_bytes();
        assert_eq!(bytes, vec![3]);

        let (decoded, consumed) = PacketType::try_from_be_bytes(&bytes).unwrap();
        assert_eq!(decoded, PacketType::Publish);
        assert_eq!(consumed, 1);

        // Test other packet types
        let packet_type = PacketType::Connect;
        let bytes = packet_type.to_be_bytes();
        assert_eq!(bytes, vec![1]);

        let (decoded, consumed) = PacketType::try_from_be_bytes(&bytes).unwrap();
        assert_eq!(decoded, PacketType::Connect);
        assert_eq!(consumed, 1);
    }
}
